---
layout: post
title: REST + GraphQL (beyond BFFs)
tag:
- graphql
- backends-for-frontends
- rest
- server-to-server
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OTe9AFXves6mRZIroTpdCQ.png" /></figure><p>In this post, we start with a brief introduction to GraphQL and its common industry accepted usage pattern as BFFs(Backends For Frontends). Can it be used beyond that? I would focus around the below questions</p><ul><li>What isÂ GraphQL?</li><li>Do I need to useÂ GraphQL?</li><li>Can GraphQL be used beyond Backends For Frontends(BFFs)?</li></ul><p><em>Basic knowledge of REST is a prerequisite for understanding the concepts in thisÂ post.</em></p><h3>What isÂ GraphQL?</h3><p>GraphQL is a <strong>query language for APIs</strong> and a <strong>runtime for fulfilling those queries with your existing data</strong>. So there are 2 components to this. A <strong>GraphQL server</strong> and a <strong>GraphQL client</strong>. Both of them talk to each other using GrpahQL query language. GraphQL is transport agnostic and works well <strong>over HTTP</strong>. The client sends a GraphQL query, the server understands what the client has asked it to do and process the request and sends the response. In the REST world, we all know what <strong>CRUD </strong>(Create, Read, Update, Delete) stands for and how it works. In the GraphQL world, the <strong>reads are Queries</strong> and the <strong>writes are Mutations</strong>. That&#39;s itÂ ðŸ˜Š</p><h4>History:</h4><p><strong>Facebook</strong>â€™s mobile apps have been powered by <strong>GraphQL</strong> <strong>since 2012</strong>. A <strong>GraphQL spec was</strong> <strong>open sourced inÂ 2015</strong>.</p><h4>Schema:</h4><p>GraphQL has a <strong>Schema, </strong>which consists of <strong>Query</strong> (for read operations) and <strong>Mutation </strong>(for write operations) with itâ€™s own type definitions.</p><pre>schema {<br>  query: Query<br>  mutation: Mutation<br>}</pre><h4>Query:</h4><p>Queries are used for read operations. Letâ€™ take a simple example in the context of Facebook. A facebook user can log in and see multiple posts from their friends with a certain number of comments. An illustrative GraphQL type definition in this case may look something likeÂ this</p><pre>type <strong>Query</strong> {<br>  posts: [<strong>Post</strong>]         # This query fetches <strong>list of Post</strong>s<br>  ...                   # Other query definitions<br>}</pre><pre>type <strong>Post</strong> {<br>  id: ID!               # Id of the post<br>  at: String!           # Time at which it was Posted<br>  caption: String!      # Caption of the post<br>  mediaUrl: String      # Url to the image or video shared<br>  location: String      # Location of the post<br>  comments: [<strong>Comment</strong>]   # Comments on the post of type Comment<br>  ...                   # Other properties definition of a post<br>}</pre><pre>type <strong>Comment</strong> { <br>  id: ID!               # Id of the comment<br>  comment: String!      # The text of the comment<br>  at: String!           # Time at which it was Commented<br>  by: String!           # The user who made the comment<br>  ...                   # Other properties definition of a Comment</pre><pre>}    </pre><h4>Sample GraphQLÂ Query:</h4><p>A sample query to fetch posts with comments for each post would look like the following</p><pre>query {<br>  posts {<br>    id<br>    at<br>    caption<br>    mediaUrl<br>    location<br>    comments {<br>      id<br>      comment<br>      at<br>      by<br>    } <br>  }<br>}</pre><p>If you look at the above query, we only ask for the <strong>required fields and nothing more </strong>for the posts as well as the comments for each post. There could be more fields both for posts and comments, which we don&#39;t need and they are not part of the response asÂ well.</p><h4>Sample GraphQLÂ Response</h4><p>Here is a sample response for the above mentioned query. Notice the top level key is &quot;<strong><em>data</em></strong>&quot; followed by the query name which is &quot;<strong><em>posts</em></strong>&quot; in thisÂ case.</p><pre>{<br>   &quot;<strong>data</strong>&quot;: {<br>     &quot;<strong>posts</strong>&quot;: [<br>       {<br>         &quot;id&quot;: &quot;some-uuid&quot;,<br>         &quot;at&quot;: &quot;2020-07-26T16:10:57.076+0000&quot;,<br>         &quot;caption&quot;: &quot;My latest post!!&quot;,<br>         &quot;mediaUrl&quot;: &quot;http://somecdn/some-image.jpg&quot;,<br>         &quot;location&quot;: &quot;Pune, India&quot;,<br>         &quot;comments&quot;: [<br>            {<br>              &quot;id&quot;: &quot;some-uuid&quot;,<br>              &quot;comment&quot;: &quot;Wow, what a place!!&quot;,<br>              &quot;at&quot;: &quot;2020-07-26T16:11:05.010+0000&quot;,<br>              &quot;by&quot;: &quot;Mahesh&quot;<br>            },<br>            {<br>              &quot;id&quot;: &quot;some-uuid&quot;,<br>              &quot;comment&quot;: &quot;I have been there too!&quot;,<br>              &quot;at&quot;: &quot;2020-07-26T17:01:30.015+0000&quot;,<br>              &quot;by&quot;: &quot;Neeta&quot;<br>            }<br>          ]<br>       },<br>       ... // more posts in similar format<br>     ]<br>   }<br>}</pre><h4>Sample GraphQL ErrorÂ Response</h4><p>In case of any error, the response would have a list of <strong>errors</strong> and the response would look something likeÂ this:</p><pre>{<br>  &quot;errors&quot;: [<br>    {<br>      &quot;errorType&quot;: &quot;SomeException&quot;,<br>      &quot;message&quot;: &quot;Some Error Message&quot; <br>    }<br>  ]<br>}</pre><h4>Mutation:</h4><p>Mutations are used for write operations. Again, in the context of Facebook, an user can share posts, like posts, add comments, delete comments etc. So the type definition for the mutations may look something likeÂ this:</p><pre>type <strong>Mutation</strong> {<br>  sharePost(post: Post!): Post<br>  likePost(post: Post!): Post<br>  addComment(postId: ID!, comment: Comment): Comment<br>  deleteComment(commentId: ID!): Comment<br>}</pre><p>We won&#39;t cover examples for the Mutations here, but I would add URLs in the references section.</p><h3>Do I need to useÂ GraphQL?</h3><p>GraphQL provides a complete and understandable description of the data in your API, gives clients<strong> the power to</strong> <strong>ask for exactly what they need and nothing more</strong>, makes it easier to evolve APIs<strong> </strong>over time, and enables powerful developer tools.</p><p>GraphQL has been a popular choice for building<strong> Backends For Frontends(BFFs), </strong>where one needs to aggregate data from multiple data sources to be consumed by their various clients like Web Browsers on Mobile devices, Android App, iOS App, Web Browsers on Desktops/Laptops etc.</p><blockquote>The data required for each of the client(Desktop, Laptop, Mobile) would vary based on the amount of data they can display based on display size of the device. We can create a BFF layer for each type of client or use something like GraphQL which allows the client to ask for exactly what itÂ needs.</blockquote><p>A picture is a worth thousand words. Let&#39;s add a few thousands ðŸ˜‰</p><h4>BFF withoutÂ GraphQL</h4><p>In this case, all the communication happens using REST and each client has it&#39;â€™s own BFF layer i.e. one for Web browser, one for Android, one for iOSÂ etc.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*MhfuM38XIOAVJbYXwwZSNQ.png" /></figure><h4>BFF with GraphQL exposed toÂ clients</h4><p>Here the clients are GraphQL aware and they talk to the API using GraphQL. The GraphQL server talks to the microservices usingÂ REST.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*WAIvjx4RBydeOywNhnrK6Q.png" /></figure><p>One can very well have multiple GraphQL endpoints dedicated for a consumer i.e. you can still have separate GraphQL BFF for Web, Android, iOS etc. Would the duplication of Schema addÂ value?</p><h4>BFF with GraphQL working behind theÂ scenes</h4><p>In this case, we use GraphQL to aggregate the microservices apis but the clients still talk using REST. The clients are not aware of GraphQL and they need not make any change. The GraphQL server still talks to the microservices usingÂ REST.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1gRvwj6wQroAKKnJ5GYf4g.png" /></figure><p>In this case also, you can have multiple BFFs for each device and each talking to multiple GraphQL APIs behind theÂ scenes</p><h4>So do I really needÂ GraphQL?</h4><p>Based on your service clients (if they are internal i.e. a customer service portal, external i.e. a self service portal or an external business to business customer), who controls their source code and the confidence you have on GraphQL, you would fall in one of the above categories for your BFF implementation. If you are not already using GraphQL, give it a try and discover for yourself, if the trade-offs are worthÂ it.</p><h3>Can GraphQL be used beyond Backends For Frontends(BFFs)?</h3><p>We know for sure, GraphQL can be helpful for BFFs but can it go beyond that. Let&#39;â€™s see if we can use GraphQL for<strong> server-to-server communication</strong>.</p><h4>GraphQL everywhere</h4><p>In this case, you may still have an aggregator GraphQL API which can aggregate the GraphQL schema of multiple microservices and give you a Graph of your entire business model. The aggregator GraphQL server talks to the microservices using GraphQL instead of REST. The microservices also talk to each other usingÂ GraphQL.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gC6fchSzdUhQzaqFRsyu_Q.png" /></figure><blockquote>As per Apollo, Appollo Federation is an answer to implementing GraphQL in a microservice architecture.</blockquote><h4>GraphQL andÂ REST</h4><p>You may have some clients where you can&#39;t force them to use GraphQL. So probably you would still have to use REST. Say you are going for GraphQL everywhere, even then, during the transition you may need to support both REST and GraphQL. Let&#39;â€™s see how itÂ looks</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*d88u6J5a8RSu7zh8DK0WjQ.png" /></figure><h4>GraphQL for Reads and REST forÂ writes</h4><p>One of the possibility is to use GraphQL only for read operations (This is where GraphQL brings a lot of value). The write operations can still be REST. In someway this may look like CQRS working in 2 different protocols for Commands(REST) and Queries (GraphQL). In the world where everyone is making a move towards Serverless architectures, achieving something like this is not very difficult either. Now the real question, is this worthÂ it?</p><h3>Conclusion</h3><p>There are more possible ways of using GraphQL for server to server communication, which is not covered here. At the moment, I have used GraphQL for a very limited server to server communication and like the power it brings. I&#39;m considering to go for GraphQL for READ (within the microservices as well) and still use REST for WRITE. I would like to hear your feedback. Have you have taken this route? Have you successfully used GraphQL beyondÂ BFFs?</p><h3>References</h3><ul><li><a href="https://martinfowler.com/articles/richardsonMaturityModel.html">REST</a> (MartinÂ Fowler)</li><li><a href="https://graphql.org">GraphQL</a></li><li><a href="https://graphql.org/learn/queries/#mutations">GraphQL Mutations</a></li><li><a href="https://philcalcado.com/2015/09/18/the_back_end_for_front_end_pattern_bff.html">Backends For Frontends</a> (PhilÂ CalÃ§ado)</li><li><a href="https://samnewman.io/patterns/architectural/bff/">Backends For Frontends</a> (SamÂ Newman)</li><li><a href="https://martinfowler.com/bliki/CQRS.html">CQRS</a> (MartinÂ Fowler)</li><li><a href="https://www.apollographql.com/blog/apollo-federation-f260cf525d21/">Appollo Federation</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1cb34170fff" width="1" height="1" alt="">
