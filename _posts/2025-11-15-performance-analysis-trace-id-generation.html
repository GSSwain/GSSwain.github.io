---
layout: post
title: "Trace ID Generation: A Performance Analysis of UUID vs. OpenTelemetry"
date: 2025-11-15
---

<p>
In high-volume systems, user experience depends on fast API responses. A slow component in your application can degrade user experience and increase infrastructure costs. This analysis, based on benchmarks from <a href="/2025/10/26/understanding-jmh-java-microbenchmark-harness-made-simple.html">my previous post</a>, shows how the choice of a trace ID generator impacts application latency, user experience, and operational costs.
</p>

<h2>The Contenders: `UUID` vs. OpenTelemetry's `IdGenerator`</h2>

<p>
Our benchmarks compared two popular methods for generating trace IDs:
</p>
{% highlight text %}
java.util.UUID.randomUUID().toString()
io.opentelemetry.sdk.trace.RandomIdGenerator.generateTraceId()
{% endhighlight %}

<h3>Implementation Differences</h3>

<p>
The performance gap stems from fundamental design choices. Here’s a side-by-side comparison:
</p>

<table class="comparison-table">
    <thead>
        <tr>
            <th>Feature</th>
            <th>UUID (Version 4)</th>
            <th>OpenTelemetry Trace ID</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Randomness Source</strong></td>
            <td><code>SecureRandom</code></td>
            <td class="highlight-otel"><code>ThreadLocalRandom</code></td>
        </tr>
        <tr>
            <td><strong>Security</strong></td>
            <td>Cryptographically Strong</td>
            <td class="highlight-otel">Non-Cryptographic</td>
        </tr>
        <tr>
            <td><strong>Random Bits</strong></td>
            <td>122 bits</td>
            <td class="highlight-otel">128 bits</td>
        </tr>
        <tr>
            <td><strong>Concurrency Model</strong></td>
            <td>Synchronized (locking)</td>
            <td class="highlight-otel">Thread-local (lock-free)</td>
        </tr>
        <tr>
            <td><strong>Standard</strong></td>
            <td>RFC 4122</td>
            <td class="highlight-otel">W3C Trace Context</td>
        </tr>
    </tbody>
</table>

<h4>The Key Takeaway: The Synchronization Bottleneck</h4>
<p>
The critical difference is the concurrency model. <code>UUID</code> uses a synchronized, shared <code>SecureRandom</code> instance, which creates a major bottleneck. Under concurrent load, threads must wait to access the generator, causing latency to increase significantly.
</p>
<p>
In contrast, OpenTelemetry's <code>IdGenerator</code> uses <code>ThreadLocalRandom</code>, giving each thread its own independent generator. This lock-free approach avoids contention entirely, allowing throughput to scale almost linearly with the number of threads. For distributed tracing—where the goal is performance and collision avoidance, not cryptographic security—this is the superior trade-off.
</p>

<h2>The Benchmark: Performance Under Pressure</h2>

<h3>Single Thread Performance Across JDK Versions</h3>

<table class="performance-table">
<thead>
<tr>
    <th class="version-col">JDK Version</th>
    <th class="impl-col">Implementation</th>
    <th class="metric-col">Average Time (ns)</th>
    <th class="metric-col">Throughput (M ops/sec)</th>
</tr>
</thead>
<tbody>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 25</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">14.321 &plusmn;0.130</td>
    <td class="metric-cell">69.8 &plusmn;0.6</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">247.141 &plusmn;8.476</td>
    <td class="metric-cell">4.0 &plusmn;0.1</td>
</tr>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 21</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">14.528 &plusmn;0.474</td>
    <td class="metric-cell">68.8 &plusmn;2.2</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">245.351 &plusmn;14.737</td>
    <td class="metric-cell">4.1 &plusmn;0.2</td>
</tr>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 17</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">14.414 &plusmn;0.241</td>
    <td class="metric-cell">69.4 &plusmn;1.2</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">862.166 &plusmn;13.122</td>
    <td class="metric-cell">1.2 &plusmn;0.0</td>
</tr>
</tbody>
</table>

<style>
.performance-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 15px;
    border: 1px solid #ddd;
}

.performance-table th,
.performance-table td {
    padding: 12px;
    text-align: right;
    border: 1px solid #ddd;
}

.performance-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    text-align: center;
}

.performance-table .version-col {
    width: 15%;
}

.performance-table .impl-col {
    width: 25%;
}

.performance-table .metric-col {
    width: 30%;
}

.performance-table .version-cell {
    background-color: #f9f9f9;
    font-weight: bold;
    text-align: center;
}

.performance-table .impl-cell {
    text-align: left;
}

.performance-table .metric-cell {
    font-family: monospace;
}

.performance-table .highlight-otel {
    background-color: #e8f5e9;
}

.performance-table tr:hover {
    background-color: #f8f9fa;
}

.jdk-row {
    border-top: 2px solid #ddd;
}

/* Comparison table styles */
.comparison-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 15px;
    border: 1px solid #ddd;
}
.comparison-table th, .comparison-table td {
    padding: 12px;
    text-align: left;
    border: 1px solid #ddd;
    vertical-align: top;
}
.comparison-table th {
    background-color: #f5f5f5;
    font-weight: bold;
    text-align: center;
}
.comparison-table .highlight-otel { background-color: #e8f5e9; }

/* Add spacing for nested lists for better readability */
.post-content ul ul {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
    padding-left: 2em; /* Adjust indentation for nested lists */
}

/* Style for highlighting contextual paragraphs */
.highlight-context {
    background-color: #f0f4f8; /* A light blue-grey background */
    border-left: 4px solid #4a90e2; /* A complementary blue border */
    padding: 1em 1.5em;
    margin: 2em 0;
    border-radius: 4px;
}

</style>

<h3>Multi-Thread Performance (10 Threads) Across JDK Versions</h3>

<p class="highlight-context">
While single-threaded performance provides a useful baseline, it doesn't reflect the reality of a typical web application. Modern services handle hundreds or thousands of concurrent requests, making multi-threaded performance the true test of an implementation's viability at scale. The following benchmark simulates this concurrent load with 10 threads, revealing the critical impact of synchronization on latency and throughput.
</p>

<table class="performance-table">
<thead>
<tr>
    <th class="version-col">JDK Version</th>
    <th class="impl-col">Implementation</th>
    <th class="metric-col">Average Time (ns)</th>
    <th class="metric-col">Throughput (M ops/sec)</th>
</tr>
</thead>
<tbody>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 25</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">24.967 &plusmn;1.525</td>
    <td class="metric-cell">400.5 &plusmn;24.4</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">3,761.317 &plusmn;65.991</td>
    <td class="metric-cell">2.7 &plusmn;0.1</td>
</tr>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 21</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">23.517 &plusmn;1.003</td>
    <td class="metric-cell">425.2 &plusmn;18.1</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">4,032.508 &plusmn;176.588</td>
    <td class="metric-cell">2.5 &plusmn;0.1</td>
</tr>
<tr class="jdk-row">
    <td rowspan="2" class="version-cell">JDK 17</td>
    <td class="impl-cell highlight-otel">OpenTelemetry</td>
    <td class="metric-cell">23.236 &plusmn;0.393</td>
    <td class="metric-cell">430.4 &plusmn;7.3</td>
</tr>
<tr>
    <td class="impl-cell">UUID</td>
    <td class="metric-cell">12,327.410 &plusmn;886.314</td>
    <td class="metric-cell">0.8 &plusmn;0.1</td>
</tr>
</tbody>
</table>
<br>

<h2>Analysis: What the Numbers Tell Us</h2>

<h4>OpenTelemetry's Performance Stability</h4>
<p>
OpenTelemetry's performance is consistent. Latency remains low (~14 ns) in single-threaded mode and only increases slightly (~24 ns) under concurrent load. This shows the effectiveness of its lock-free, thread-local design, which scales very well.
</p>

<h4>UUID's Problem with Concurrency</h4>
<p>
While newer JDKs have improved <code>UUID</code> performance (a 3x improvement from JDK 17 to 21 in multi-threaded tests), its performance still degrades under load. The latency increases by <strong>15-20x</strong> when moving from a single thread to ten threads. This is a direct result of the synchronization bottleneck in <code>SecureRandom</code>.
</p>

<h4>The Performance Gap</h4>
<p>
The performance difference becomes much larger under concurrent load.
</p>
<ul>
    <li>On <strong>JDK 25</strong>, OpenTelemetry is <strong>17x</strong> faster in a single thread and <strong>150x</strong> faster with 10 threads.</li>
    <li>On <strong>JDK 17</strong>, the gap is larger: <strong>60x</strong> faster in a single thread and <strong>530x</strong> faster with 10 threads.</li>
</ul>
<p>
This proves that for any modern, concurrent application, <code>UUID.randomUUID()</code> is a significant performance liability for tracing.
</p>

<h2>The Impact on Applications and Infrastructure</h2>

<p>
The benchmark results have clear consequences for applications and infrastructure. Here’s how the performance difference translates into real-world outcomes.
</p>

<h4>1. Slower Response Times and Poor User Experience</h4>
<p>In a high-volume system, the <strong>15-20x latency increase</strong> with <code>UUID</code> under concurrent load directly impacts every user request. This causes slower API responses and a poor user experience, especially during peak traffic. A system that is fast with one user can become very slow with many users.</p>
<p>It's also important to note that these benchmarks were run in a controlled environment without the overhead of competing application threads. In a real-world production workload, where the CPU is busy executing business logic and contending for other resources, the impact of <code>UUID</code>'s locking mechanism would be even more severe. The 15-20x latency explosion we measured is likely a conservative estimate; the actual tax on a busy production server is much higher.</p>

<h4>2. Inflated Infrastructure Costs</h4>
<p>To compensate for the inefficiency of <code>UUID</code>, teams often need to add more servers. The poor scaling means more hardware is required to handle the same workload, which increases infrastructure costs. By choosing a lock-free generator, you can serve more users with less hardware, directly reducing operational spending.</p>

<h4>3. Unpredictable System Performance</h4>
<p>The stable performance of OpenTelemetry's generator allows for reliable capacity planning. In contrast, the poor scaling of <code>UUID</code> makes it difficult to predict resource needs and ensure system stability during traffic spikes. This uncertainty can lead to service degradations or outages.</p>

<h2>Implementation Recommendations</h2>

<p>
Based on our comprehensive analysis across JDK versions and threading scenarios:
</p>

<h4>For New Projects: The Clear Winner</h4>
<p>
For any new Java application requiring distributed tracing, <strong>OpenTelemetry's <code>IdGenerator</code> should be the default choice</strong>. It is faster, scales better, and aligns with the W3C Trace Context standard, making it a future-proof decision.
</p>

<h4>For Existing Systems: A Strategic Migration</h4>
<p>Priority for migration based on scenarios:</p>

<table class="migration-table">
<thead>
<tr>
    <th class="scenario-col">Scenario</th>
    <th class="priority-col">Migration Priority</th>
    <th class="impact-col">Expected Impact</th>
</tr>
</thead>
<tbody>
<tr class="priority-critical">
    <td>JDK 17 + High Concurrency</td>
    <td class="priority-cell">Critical</td>
    <td class="impact-cell">530x performance improvement</td>
</tr>
<tr class="priority-high">
    <td>JDK 17 + Single Thread</td>
    <td class="priority-cell">High</td>
    <td class="impact-cell">60x performance improvement</td>
</tr>
<tr class="priority-medium">
    <td>JDK 21/25 + High Concurrency</td>
    <td class="priority-cell">Medium</td>
    <td class="impact-cell">150-170x performance improvement</td>
</tr>
<tr class="priority-low">
    <td>JDK 21/25 + Single Thread</td>
    <td class="priority-cell">Low</td>
    <td class="impact-cell">17x performance improvement</td>
</tr>
</tbody>
</table>

<style>
.migration-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 15px;
    border: 1px solid #ddd;
}

.migration-table th,
.migration-table td {
    padding: 12px;
    border: 1px solid #ddd;
    text-align: left;
}

.migration-table th {
    background-color: #f5f5f5;
    font-weight: bold;
}

.migration-table .scenario-col {
    width: 40%;
}

.migration-table .priority-col {
    width: 25%;
}

.migration-table .impact-col {
    width: 35%;
}

.migration-table .priority-cell {
    text-align: center;
    font-weight: bold;
}

.migration-table .impact-cell {
    text-align: right;
    font-family: monospace;
}

.migration-table .priority-critical td {
    background-color: #ffebee;
}

.migration-table .priority-high td {
    background-color: #fff3e0;
}

.migration-table .priority-medium td {
    background-color: #f1f8e9;
}

.migration-table .priority-low td {
    background-color: #f5f5f5;
}

.migration-table tr:hover td {
    filter: brightness(95%);
}
</style>

<h2>Conclusion</h2>

<p>
This analysis proves that a technical choice, like the method for generating trace IDs, has a direct and measurable impact on user experience and infrastructure costs. For any high-throughput service, optimizing this component is a straightforward way to build faster, more reliable applications that cost less to run. At scale, small performance differences become significant, and making informed technical decisions is critical for success.
</p>

<p>
The complete benchmark code and detailed results are available in the <a href="https://github.com/GSSwain/benchmark-trace-id-generator">benchmark-trace-id-generator</a> repository.
</p>