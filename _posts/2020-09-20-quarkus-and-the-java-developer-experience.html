---
layout: post
title: Quarkus and the Java Developer Experience
tag:
- containers
- java
- graalvm
- developer-experience
- quarkus
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4Oxs97dZeDJuT4UnvIAc9g.jpeg" /></figure><p>This post covers </p><ul><li>What is Quarkus? </li><li>Getting started with Quarkus. </li><li>What is native executable? </li><li>Building <em>native executable from Java using Quarkus</em>. </li><li>Startup time difference for Jar and native executables. </li><li><em>Hot code replacement</em> for Java (For me this is one of the biggest USP of the framework). </li></ul><h3>What is Quarkus?</h3><blockquote>Quarkus is a full-stack, Kubernetes-native <a href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-a-Java-framework">Java framework</a> made for Java virtual machines (JVMs) and native compilation, optimizing Java specifically for containers and enabling it to become an effective platform for <a href="https://www.redhat.com/en/topics/cloud-native-apps/what-is-serverless">serverless</a>, <a href="https://www.redhat.com/en/topics/cloud">cloud</a>, and <a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes">Kubernetes</a> environments.</blockquote><h3>Getting started with Quarkus</h3><p>You would need to have Java 8 or Java 11 installed along with Maven to get started with Quarkus.</p><h4>Create a Boilerplate REST project</h4><p>Let’s use the Maven plugin to create a boilerplate</p><pre>mvn io.quarkus:quarkus-maven-plugin:1.8.1.Final:create</pre><p>Now it would ask for the <em>groupId, artifcatId, version </em>to be entered. It would also ask if we want a REST resource (say yes) followed by the <em>classname</em> and the <em>path</em> of the rest resource. This is how it would look like</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1016/1*Ynag2d-Mio8ptTapuA2MHQ.png" /></figure><p>Now we have a Quarkus boilerplate project ready to be build and run.</p><h4>Build the project</h4><p>To create a Jar run the following command.</p><p>mvn package</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1004/1*E0Wnq1tElKnKdakJCK6aaQ.jpeg" /></figure><p>The build took around <strong>16 seconds</strong>.</p><p>We cover building <em>native executable</em> in the next section.</p><h4>Run the project</h4><p>java -jar target/quarkus-hello-world-1.0-SNAPSHOT-runner.jar</p><h4>Test the project</h4><p>Either use curl or open it on a browser and check</p><p>curl <a href="http://localhost:8080/hello">http://localhost:8080/hello</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/904/1*vB8gHFcpTJ3Uahle9dzxgQ.png" /></figure><h3>What is native executable?</h3><p>In the world of Java, we compile the source code to Java byte code (Job of <em>javac</em>). When we run this compiled code, the Java byte code is converted to machine specific code (<em>JRE</em> does this). What if we could compile the Java source code to machine specific code and run the machine code directly without a JRE. This is exactly what a native executable is and <strong><em>GraalVM</em></strong> <em>native-image</em> can do this for us.</p><blockquote>With native executables, we don’t need the JRE to run java code anymore . Those native executables are <strong>faster to bootstrap</strong> and <strong>need less resources to run</strong>. The only thing we need to give up is the <strong>Write</strong> <strong>Once Run Anywhere (WORA)</strong>. That means the code would only run on similar systems on which it was compiled. But wait! Can’t we build for a specific machine and run the code along with that machine? Yes, we could do this with a <strong>container-image</strong>. So we still get WORA as long as the <strong>container run time can run on any machine</strong>.</blockquote><h3>Building native executable from Java using Quarkus</h3><p>With Quarkus we can build the following native executables</p><ol><li>Native executable for our development machine (Won’t run on different OS or even with same OS)</li><li>Container image with native executable (Runs everywhere where the container runtime is supported)</li></ol><h3>1. Build native executable for our development machine</h3><p>Following are the steps to create a native executable for your development machine.</p><ul><li><a href="https://www.graalvm.org/docs/getting-started-with-graalvm/#install-graalvm">Install GraalVM</a></li><li>Set <em>GRAALVM_HOME </em>environment variable</li><li>Add <em>GRAALVM_HOME/bin </em>directory to<em> PATH</em></li><li>Install GraalVM <em>native-image</em> utility (Run gu install native-image)</li><li>Set up <em>C </em>Langauge environment (Varies for different OS and covered below)</li><li>Finally run maven package with the native profile enabled (On Windows an extra step is required and covered below)</li></ul><h4>Setting up C</h4><p>On a Mac run the following command</p><pre>xcode-select --install</pre><p>On a Linux based system run the following command</p><pre># dnf (rpm-based)<br>sudo dnf install gcc glibc-devel zlib-devel libstdc++-static<br># Debian-based distributions:<br>sudo apt-get install build-essential libz-dev zlib1g-dev</pre><p>On Windows 10, get the <em>Visual Studio 2019 C++ build tools</em> and install the checked optional packages (I have used the community edition)</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*4_v2StXKD9p7G7k6wZhBsQ.jpeg" /></figure><h4>Build native executable</h4><p>For building the native image, we need to run the following command</p><p>mvn package -Pnative</p><p>For Windows 10, you <strong>must be using the command prompt</strong> (does not work on PowerShell yet). You need to run the following batch file before running the native maven build (The path to this file would vary depending upon the version of Visual Studio e.g. 2019, 2017 and if it Community or not)</p><pre>&quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat&quot;</pre><p>I have created a cmd file (native-build-windows.cmd) which runs both the commands for me.</p><pre>call &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat&quot;</pre><pre>mvn package -Pnative</pre><p>Once you run this, you would get a native executable</p><p>On Mac, it creates an executable file named quarkus-hello-world-1.0-SNAPSHOT-runner under the target directory.</p><p>On Windows-10 an <em>exe </em>named<em> </em>quarkus-hello-world-1.0-SNAPSHOT-runner.exe is created under the target diectory.</p><p>Run this file and do a round of testing. Note this executable will not run on different OS and may not run on different machines with same OS as well. So we need to create a container image which would run irrespective of the OS.</p><h3>2. Building container image with native executable</h3><p>Let’s start Docker and get going. (Allow file sharing on Docker)</p><p>Run the following command</p><p>mvn package -Pnative -Dquarkus.native.container-build=true</p><p>It would again build an executable but this time if you run it on your own machine, it would fail as the container build happens on the ubi-quarkus-native-image:20.2.0-java11 container.</p><p>To run the executable, we can create a container image and run that with the following command</p><pre># Build the image<br>docker build -f src/main/docker/Dockerfile.native -t quarkus/quarkus-hello-world .</pre><pre># Run the image<br>docker run -i --rm -p 8080:8080 quarkus/quarkus-hello-world</pre><p>This brings ubi8/ubi-minimal:8.1 image as the runtime for the executable.</p><p>There is an easier way to create the container image. Just add the following Quarkus extension using the below command</p><p>mvn quarkus:add-extension -Dextensions=quarkus-container-image-jib</p><p>Run the following command to build the Docker image</p><pre>mvn package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*LFAA1qIqyN2osZoGSSCz3g.jpeg" /></figure><p>The build took around <strong>8 minutes</strong>.</p><p>By default the container image group is your user-name of the PC. You can change it with setting a different value for quarkus.container-image.group in the application.properties file</p><p>Now run the docker image (Replace the container-image-group value)</p><p>docker run -I --rm -p 8080:8080 &lt;container-image-group&gt;/quarkus-hello-world:1.0-SNAPSHOT</p><h3>Startup time difference for Jar and native executables</h3><p>Here is a quick summary of the startup time for the various kinds of builds and runtime on a Windows 10 with 20GB of RAM with intel i5 processor.</p><p>The <strong>jar</strong> version took around<strong> 1.773 seconds</strong>, the <strong>native machine executable</strong> started in <strong>0.281 seconds</strong> and the <strong>native container image</strong> started in <strong>0.017 seconds</strong> 😊.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*GEywE23svFHY4miD8gxgXw.jpeg" /></figure><h3>Hot code replacement for Java</h3><p>Hot code replacement is the idea, where we replace code which is already running. This was always there, <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools">SpringBoot Dev-tools</a> does this when the <em>classpath</em> gets updated. The hot code replacement with Quarkus is cool and very similar in experience to the NodeJS based eco-system (with a watch option on source files). It detects the changes on the source files, compiles them and replaces them.</p><p>Let’s see this in action</p><p>Start the project in dev mode</p><pre>mvnw quarkus:dev</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PwpeEFL-tvSlsne5sx2Wbg.jpeg" /></figure><p>Now let’s return “<em>hi” </em>instead of <em>“hello” </em>(any change would do) and save the file. You would notice the source file change would be detected and it would hot replace the code.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZlLQK8WzoOJurGzC55xa7g.jpeg" /></figure><p>This certainly saves a few seconds to minutes (depending on your machine 😜). ❤️ this feature.</p><h3>Conclusion:</h3><p>Quarkus looks really good. I like the way it has given the much needed boost to the Java Developer experience and make us feel more productive. The supported eco-system is also promising (See it for yourself with mvn quarkus:list-extensions). I hope you would give it a try and discover for yourself.</p><h3>References:</h3><ul><li><a href="https://quarkus.io">Quarkus</a></li><li><a href="https://www.graalvm.org/why-graalvm/">GraalVM</a></li><li><a href="https://www.docker.com">Docker</a></li></ul><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b9817fe4e3d7" width="1" height="1" alt=""><hr><p><a href="https://medium.com/swlh/quarkus-and-the-java-developer-experience-b9817fe4e3d7">Quarkus and the Java Developer Experience</a> was originally published in <a href="https://medium.com/swlh">The Startup</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
